(window.webpackJsonp=window.webpackJsonp||[]).push([[167],{679:function(e,v,a){"use strict";a.r(v);var _=a(6),t=Object(_.a)({},(function(){var e=this,v=e.$createElement,a=e._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"性能优化小册-异步堆栈追踪-为什么-await-胜过-promise"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能优化小册-异步堆栈追踪-为什么-await-胜过-promise"}},[e._v("#")]),e._v(" 性能优化小册 - 异步堆栈追踪：为什么 await 胜过 Promise")]),e._v(" "),a("p",[e._v("与直接使用 "),a("code",[e._v("Promise")]),e._v(" 相比，使用 "),a("code",[e._v("async/await")]),e._v(" 不仅可以使代码更具可读性，而且还可以在 JavaScript 引擎中实现一些有趣的优化。")]),e._v(" "),a("p",[e._v("这篇文章是关于一个这样的优化，涉及异步代码的堆栈追踪。")]),e._v(" "),a("p",[a("code",[e._v("async/await")]),e._v(" 和 "),a("code",[e._v("Promise")]),e._v(" 的根本区别在于 "),a("code",[e._v("await fn()")]),e._v(" 暂停当前函数的执行，而 "),a("code",[e._v("promise.then(fn)")]),e._v(" 在将 "),a("code",[e._v("fn")]),e._v(" 调用添加到回调链后，继续执行当前函数。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const fn = () => console.log(\'hello\')\nconst a = async () => {\n  await fn() // 暂停 fn 的执行\n}\n// 调用 a 时，才恢复 fn 的执行\na() // "hello"\n\nconst promise = Promise.resolve()\n// 将 fn 添加到回调链后，继续执行 fn\npromise.then(fn) // "hello"\n')])])]),a("p",[e._v("在堆栈追踪的上下文中，这种差异非常显著。")]),e._v(" "),a("p",[e._v("当一个 "),a("code",[e._v("Promise")]),e._v(" 链（无论是否脱糖化）在任何时候抛出一个未经处理的异常时， JavaScript 引擎都会显示一条错误信息和（希望）记录一个有用的堆栈追踪。")]),e._v(" "),a("p",[e._v("作为一名开发人员，无论您使用的是普通的 "),a("code",[e._v("Promise")]),e._v(" 还是 "),a("code",[e._v("async await")]),e._v("，您都会期望这样。")]),e._v(" "),a("h2",{attrs:{id:"promise"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[e._v("#")]),e._v(" Promise")]),e._v(" "),a("p",[e._v("想象一个场景，当对异步函数 "),a("code",[e._v("b")]),e._v(" 的调用解析时，调用函数 "),a("code",[e._v("c")]),e._v("：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const b = () => Promise.resolve()\nconst a = () => {\n    b().then(() => c())\n}\n")])])]),a("p",[e._v("当调用 "),a("code",[e._v("a")]),e._v(" 时，将同步发生以下情况：")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("b")]),e._v(" 被调用并返回一个 "),a("code",[e._v("Promise")]),e._v("，该 "),a("code",[e._v("Promise")]),e._v(" 将在将来某个时刻解决。")]),e._v(" "),a("li",[a("code",[e._v(".then")]),e._v(" 回调（实际上是调用 "),a("code",[e._v("c()")]),e._v("）被添加到回调链中（ V8 术语中，[…]被添加为解析处理程序）。")])]),e._v(" "),a("p",[e._v("之后，我们完成了在函数 "),a("code",[e._v("a")]),e._v(" 的主体中执行代码。"),a("code",[e._v("a")]),e._v(" 永远不会被挂起，当对 "),a("code",[e._v("b")]),e._v(" 的异步调用解析时，上下文已经消失了。")]),e._v(" "),a("p",[e._v("想象一下如果 "),a("code",[e._v("b")]),e._v("（或 "),a("code",[e._v("c")]),e._v(" ）异步抛出异常会发生什么？理想情况下，堆栈追踪应该包括 "),a("code",[e._v("a")]),e._v("，因为 "),a("code",[e._v("b")]),e._v("（或 "),a("code",[e._v("c")]),e._v("）是从那里调用的，对吧？既然我们不在参考 "),a("code",[e._v("a")]),e._v(" 了 ，那怎样能做到呢？")]),e._v(" "),a("p",[e._v("为了让它工作，JavaScript 引擎需要在上面的步骤之外做一些事情："),a("strong",[e._v("它在有机会的时候捕获并存储堆栈追踪。")])]),e._v(" "),a("p",[e._v("在 "),a("strong",[e._v("V8")]),e._v(" 中，堆栈追踪附加到 "),a("code",[e._v("b")]),e._v(" 返回的 "),a("code",[e._v("Promise")]),e._v("。当 "),a("code",[e._v("Promise")]),e._v(" 实现时，堆栈追踪将被传递，以便 "),a("code",[e._v("c")]),e._v(" 可以根据需要使用它。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("b()[a] -> b().then()[a] -> c[a?:a]\n")])])]),a("p",[a("strong",[e._v("捕获堆栈追踪需要时间（即降低性能）；存储这些堆栈追踪需要内存。")])]),e._v(" "),a("h2",{attrs:{id:"async-await"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#async-await"}},[e._v("#")]),e._v(" async/await")]),e._v(" "),a("p",[e._v("下面是同样的程序，使用 "),a("code",[e._v("async/await")]),e._v(" 而不是 "),a("code",[e._v("Promise")]),e._v(" 编写：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const b = () => Promise.resolve()\nconst a = async () => {\n  await b()\n  c()\n}\n")])])]),a("p",[e._v("使用 "),a("code",[e._v("await")]),e._v("，即使在 "),a("code",[e._v("await")]),e._v(" 调用中不收集堆栈追踪，我们也可以恢复调用链。")]),e._v(" "),a("p",[e._v("这是可能的，因为 "),a("code",[e._v("a")]),e._v(" 被挂起，正在等待 "),a("code",[e._v("b")]),e._v(" 解决。如果 "),a("code",[e._v("b")]),e._v(" 抛出异常，则可以按需以这种方式重建堆栈追踪。")]),e._v(" "),a("p",[e._v("如果 "),a("code",[e._v("c")]),e._v(" 抛出异常，堆栈追踪可以像同步函数那样构造，因为发生这种情况时，我们仍在 "),a("code",[e._v("a")]),e._v(" 上下文中。")]),e._v(" "),a("p",[e._v("通过遵循以下建议，使 JavaScript 引擎能够以更高效的方式处理堆栈追踪：")]),e._v(" "),a("ul",[a("li",[e._v("偏好 "),a("code",[e._v("async/await")]),e._v(" 胜过 "),a("code",[e._v("Promise")]),e._v("。")]),e._v(" "),a("li",[e._v("使用 "),a("a",{attrs:{href:"https://babeljs.io/docs/en/next/babel-preset-env.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("@babel/preset env"),a("OutboundLink")],1),e._v(" 避免不必要的 "),a("code",[e._v("async/await")]),e._v(" 传输。")])]),e._v(" "),a("p",[a("a",{attrs:{href:"https://mathiasbynens.be/notes/async-stack-traces",target:"_blank",rel:"noopener noreferrer"}},[e._v("英语原文"),a("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=t.exports}}]);