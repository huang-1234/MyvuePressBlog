(window.webpackJsonp=window.webpackJsonp||[]).push([[278],{781:function(t,e,r){"use strict";r.r(e);var s=r(6),i=Object(s.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"error1-2021年3月20晚上"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#error1-2021年3月20晚上"}},[t._v("#")]),t._v(" error1 2021年3月20晚上")]),t._v(" "),r("p",[t._v("在git项目中我们提交代码的时候经常遇到这样的报错：")]),t._v(" "),r("div",{staticClass:"language-git extra-class"},[r("pre",{pre:!0,attrs:{class:"language-git"}},[r("code",[r("span",{pre:!0,attrs:{class:"token command"}},[t._v("$ git commit"),r("span",{pre:!0,attrs:{class:"token parameter"}},[t._v(" -am")])]),r("span",{pre:!0,attrs:{class:"token string"}},[t._v("'some messsage'")]),t._v("\nfatal: Unable to create "),r("span",{pre:!0,attrs:{class:"token string"}},[t._v("'/XXXXXX/.git/index.lock'")]),t._v(": File exists.\n\nIf no other git process is currently running, this probably means a\ngit process crashed in this repository earlier. Make sure no other git\nprocess is running and remove the file manually to continue.\n")])])]),r("p",[t._v("这时候提交会失败。\n解决办法是，到.git目录下，删除index.lock文件，就能正常提交了。\n那index.lock有什么作用呢？\n官方是这么说的：")]),t._v(" "),r("p",[t._v("在进行某些比较费时的git操作时自动生成，操作结束后自动删除，相当于一个锁定文件，目的在于防止对一个目录同时进行多个操作。有时强制关闭进行中的git操作，这个文件没有被自动删除，之后你就无法进行其他操作，必须手动删除。")]),t._v(" "),r("p",[t._v("通俗讲，就是我们在commit的时候，会自动生成一个index.lock文件，操作完成后，会自动删除。如果在commit过程中，产生了意外，比如手动退出了，电脑死机了，断网了等等，导致操作失败，没有自动删除index.lock文件，那么下次再commit的时候，系统不知道你的index.lock没删除，它会傻傻的再去创建index.lock文件，这时候，发现已经目录下已经有一个index.lock文件了，懵逼了，不知道咋处理了，所以抛错给你：")]),t._v(" "),r("p",[t._v("fatal: Unable to create '/XXXXXX/.git/index.lock': File exists.\n1\n字面意思就是，创建index.lock文件失败，因为File exists：文件已存在。\n这就是这个报错的来源。")]),t._v(" "),r("h2",{attrs:{id:"_210506"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_210506"}},[t._v("#")]),t._v(" 210506")]),t._v(" "),r("p",[t._v("Git使用中报错fatal: The current branch master has no upstream branch.解决方案")]),t._v(" "),r("p",[t._v("具体原因： 出现这种情况主要是由于远程仓库太多，且分支较多。在默认情况下，"),r("code",[t._v("git push")]),t._v("时一般会上传到"),r("code",[t._v("origin")]),t._v("下的"),r("code",[t._v("master")]),t._v("分支上，然而当repository和branch过多，而又没有设置关联时，git就会产生疑问，因为它无法判断你的push目标。")]),t._v(" "),r("p",[t._v("Git 的 “master” 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有 master 分支，是因为"),r("code",[t._v("git init")]),t._v("命令默认创建它，并且大多数人都懒得去改动它。\n远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。origin” 是当你运行git clone时默认的远程仓库名字。 如果你运行 "),r("code",[t._v("git clone -o booyah")]),t._v("，那么你默认的远程分支名字将会是 "),r("code",[t._v("booyah/master")]),t._v("。")]),t._v(" "),r("p",[t._v("解决办法其实就是确定这两个值，方法有两种：")]),t._v(" "),r("ul",[r("li",[t._v("第一种如上图中的提示："),r("code",[t._v("git push --set-upstream origin master")]),t._v("。其中的origin是你在clone远程代码时，git为你创建的指向这个远程代码库的标签，它指向repository。为了能清楚了解你要指向的repository，可以用命令git remote -v进行查看。master是你远程的branch，可以用"),r("code",[t._v("git branch -a")]),t._v("查看所有分支，远程分支是红色的部分。然后确定好这两个值后，将值换掉即可。")]),t._v(" "),r("li",[t._v("另一种方法是："),r("code",[t._v("git push -u origin master")]),t._v("。同样根据自己的需要，替换origin和master。\n两个命令的区别是第一条命令是要保证你的远程分支存在，如果不存在，也就无法进行关联。而第二条指令即使远程没有你要关联的分支，它也会自动创建一个出来，以实现关联。")])])])}),[],!1,null,null,null);e.default=i.exports}}]);