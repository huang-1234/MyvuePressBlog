(window.webpackJsonp=window.webpackJsonp||[]).push([[130],{307:function(e,t,n){"use strict";function a(e,t,n,a,s,r,v,o){var c,_="function"==typeof e?e.options:e;if(t&&(_.render=t,_.staticRenderFns=n,_._compiled=!0),a&&(_.functional=!0),r&&(_._scopeId="data-v-"+r),v?(c=function(e){(e=e||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(e=__VUE_SSR_CONTEXT__),s&&s.call(this,e),e&&e._registeredComponents&&e._registeredComponents.add(v)},_._ssrRegister=c):s&&(c=o?function(){s.call(this,(_.functional?this.parent:this).$root.$options.shadowRoot)}:s),c)if(_.functional){_._injectStyles=c;var i=_.render;_.render=function(e,t){return c.call(t),i(e,t)}}else{var l=_.beforeCreate;_.beforeCreate=l?[].concat(l,c):[c]}return{exports:e,options:_}}n.d(t,"a",(function(){return a}))},489:function(e,t,n){"use strict";n.r(t);var a=n(307),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:""}},[n("a",{staticClass:"header-anchor",attrs:{href:"#"}},[e._v("#")])]),e._v(" "),n("h2",{attrs:{id:"优化自动刷新的性能"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#优化自动刷新的性能"}},[e._v("#")]),e._v(" 优化自动刷新的性能")]),e._v(" "),n("p",[n("code",[e._v("devServer.inline")]),e._v("是用来控制是否往"),n("code",[e._v("Chunk")]),e._v("中注入代理客户端的，默认会注入。 事实上，在开启"),n("code",[e._v("inline")]),e._v("时，DevServer会为每个输出的"),n("code",[e._v("Chunk")]),e._v("中注入代理客户端的代码，当你的项目需要输出的"),n("code",[e._v("Chunk")]),e._v("有很多个时，这会导致你的构建缓慢。 其实要完成自动刷新，一个页面只需要一个代理客户端就行了，DevServer之所以粗暴的为每个"),n("code",[e._v("Chunk")]),e._v("都注入，是因为它不知道某个网页依赖哪几个"),n("code",[e._v("Chunk")]),e._v("，索性就全部都注入一个代理客户端。 网页只要依赖了其中任何一个"),n("code",[e._v("Chunk")]),e._v("，代理客户端就被注入到网页中去。")]),e._v(" "),n("p",[e._v("这里优化的思路是关闭还不够优雅的"),n("code",[e._v("inline")]),e._v("模式，只注入一个代理客户端。 为了关闭"),n("code",[e._v("inline")]),e._v("模式，在启动DevServer时，可通过执行命令"),n("code",[e._v("webpack-dev-server --inline false")]),e._v("（也可以在配置文件中设置），这时输出的日志如下：")]),e._v(" "),n("div",{staticClass:"language-csharp extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("> webpack-dev-server --inline false\n\nProject is running at http://localhost:8080/webpack-dev-server/\nwebpack output is served from /\nHash: 5a43fc44b5e85f4c2cf1\nVersion: webpack 3.5.5\nTime: 1130ms\n        Asset    Size  Chunks                    Chunk Names\n    bundle.js  750 kB       0  [emitted]  [big]  main\nbundle.js.map  897 kB       0  [emitted]         main\n  [81] ./main.js 2.29 kB {0} [built]\n    + 169 hidden modules\n")])])]),n("p",[e._v("要开发的网页被放进了一个"),n("code",[e._v("iframe")]),e._v("中，编辑源码后，"),n("code",[e._v("iframe")]),e._v("会被自动刷新。 同时你会发现构建时间从1566ms减少到了1130ms，说明优化生效了。构建性能提升的效果在要输出的"),n("code",[e._v("Chunk")]),e._v("数量越多时会显得越突出。\n如果你不想通过"),n("code",[e._v("iframe")]),e._v("的方式去访问，但同时又想让网页保持自动刷新功能，你需要手动往网页中注入代理客户端脚本，往"),n("code",[e._v("index.html")]),e._v("中插入以下标签：")]),e._v(" "),n("div",{staticClass:"language-xml extra-class"},[n("pre",{pre:!0,attrs:{class:"language-xml"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("\x3c!--注入 DevServer 提供的代理客户端脚本，这个服务是 DevServer 内置的--\x3e")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),e._v("script")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("src")]),n("span",{pre:!0,attrs:{class:"token attr-value"}},[n("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[e._v("=")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v('"')]),e._v("http://localhost:8080/webpack-dev-server.js"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v('"')])]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("</")]),e._v("script")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("\n")])])]),n("p",[e._v("给网页注入以上脚本后，独立打开的网页就能自动刷新了。但是要注意在发布到线上时记得删除掉这段用于开发环境的代码。")]),e._v(" "),n("h2",{attrs:{id:"开启模块热替换"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#开启模块热替换"}},[e._v("#")]),e._v(" 开启模块热替换")]),e._v(" "),n("p",[e._v("要做到实时预览，除了使用自动刷新刷新整个网页外，DevServer还支持一种叫做模块热替换("),n("code",[e._v("Hot Module Replacement")]),e._v(")的技术可在不刷新整个网页的情况下做到超灵敏的实时预览。 原理是当一个源码发生变化时，只重新编译发生变化的模块，再用新输出的模块替换掉浏览器中对应的老模块。\n模块热替换技术的优势有：")]),e._v(" "),n("ul",[n("li",[e._v("实时预览反应更快，等待时间更短。")]),e._v(" "),n("li",[e._v("不刷新浏览器能保留当前网页的运行状态，例如在使用Redux来管理数据的应用中搭配模块热替换能做到代码更新时Redux中的数据还保持不变。")])]),e._v(" "),n("p",[e._v("总的来说模块热替换技术很大程度上的提高了开发效率和体验。")]),e._v(" "),n("h4",{attrs:{id:"模块热替换的原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#模块热替换的原理"}},[e._v("#")]),e._v(" 模块热替换的原理")]),e._v(" "),n("p",[e._v("模块热替换的原理和自动刷新原理类似，都需要往要开发的网页中注入一个代理客户端用于连接DevServer和网页， 不同在于模块热替换独特的模块替换机制。\nDevServer默认不会开启模块热替换模式，要开启该模式，只需在启动时带上参数"),n("code",[e._v("--hot")]),e._v("，完整命令是"),n("code",[e._v("webpack-dev-server --hot")]),e._v("。\n除了通过在启动时带上"),n("code",[e._v("--hot")]),e._v("参数，还可以通过接入"),n("code",[e._v("Plugin")]),e._v("实现，相关代码如下：")]),e._v(" "),n("div",{staticClass:"language-java extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const HotModuleReplacementPlugin = require('webpack/lib/HotModuleReplacementPlugin');\nmodule.exports = {\n  entry:{\n    // 为每个入口都注入代理客户端\n    main:['webpack-dev-server/client?http://localhost:8080/', 'webpack/hot/dev-server','./src/main.js'],\n  },\n  plugins: [\n    // 该插件的作用就是实现模块热替换，实际上当启动时带上 `--hot` 参数，会注入该插件，生成 .hot-update.json 文件。\n    new HotModuleReplacementPlugin(),\n  ],\n  devServer:{\n    // 告诉 DevServer 要开启模块热替换模式\n    hot: true,      \n  }  \n};\n")])])]),n("p",[e._v("在启动Webpack时带上参数"),n("code",[e._v("--hot")]),e._v("其实就是自动为你完成以上配置。")])])}),[],!1,null,null,null);t.default=s.exports}}]);