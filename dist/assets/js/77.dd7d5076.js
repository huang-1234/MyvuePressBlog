(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{307:function(e,n,r){"use strict";function t(e,n,r,t,o,s,l,i){var a,v="function"==typeof e?e.options:e;if(n&&(v.render=n,v.staticRenderFns=r,v._compiled=!0),t&&(v.functional=!0),s&&(v._scopeId="data-v-"+s),l?(a=function(e){(e=e||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(e=__VUE_SSR_CONTEXT__),o&&o.call(this,e),e&&e._registeredComponents&&e._registeredComponents.add(l)},v._ssrRegister=a):o&&(a=i?function(){o.call(this,(v.functional?this.parent:this).$root.$options.shadowRoot)}:o),a)if(v.functional){v._injectStyles=a;var c=v.render;v.render=function(e,n){return a.call(n),c(e,n)}}else{var _=v.beforeCreate;v.beforeCreate=_?[].concat(_,a):[a]}return{exports:e,options:v}}r.d(n,"a",(function(){return t}))},437:function(e,n,r){"use strict";r.r(n);var t=r(307),o=Object(t.a)({},(function(){var e=this,n=e.$createElement,r=e._self._c||n;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"promise-a-规范"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise-a-规范"}},[e._v("#")]),e._v(" Promise/A+规范")]),e._v(" "),r("p",[e._v("翻译：")]),e._v(" "),r("p",[e._v("Promise表示一个异步操作的最终结果。与Promise最主要的交互方法是通过将函数传入它的then方法从而获取得Promise最终的值或Promise最终最拒绝（reject）的原因。")]),e._v(" "),r("h2",{attrs:{id:"_1-术语"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-术语"}},[e._v("#")]),e._v(" 1. 术语")]),e._v(" "),r("p",[r("code",[e._v("promise")]),e._v("是一个包含了兼容promise规范then方法的对象或函数，\n"),r("code",[e._v("thenable")]),e._v(" 是一个包含了then方法的对象或函数。\n"),r("code",[e._v("value")]),e._v(" 是任何Javascript值。 (包括 undefined, thenable, promise等).\n"),r("code",[e._v("exception")]),e._v(" 是由"),r("code",[e._v("throw")]),e._v("表达式抛出来的值。\n"),r("code",[e._v("reason")]),e._v(" 是一个用于描述Promise被拒绝原因的值。")]),e._v(" "),r("h2",{attrs:{id:"_2-要求"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-要求"}},[e._v("#")]),e._v(" 2. 要求")]),e._v(" "),r("h3",{attrs:{id:"_2-1-promise状态"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-promise状态"}},[e._v("#")]),e._v(" 2.1 Promise状态")]),e._v(" "),r("p",[e._v("一个Promise必须处在其中之一的状态：pending, fulfilled 或 rejected.")]),e._v(" "),r("ul",[r("li",[e._v("如果是pending状态,则promise：\n"),r("ul",[r("li",[e._v("可以转换到fulfilled或rejected状态。")])])]),e._v(" "),r("li",[e._v("如果是fulfilled状态,则promise：\n"),r("ul",[r("li",[e._v("不能转换成任何其它状态。")]),e._v(" "),r("li",[e._v("必须有一个值，且这个值不能被改变。")])])]),e._v(" "),r("li",[e._v("如果是rejected状态,则promise可以：\n"),r("ul",[r("li",[e._v("不能转换成任何其它状态。")]),e._v(" "),r("li",[e._v("必须有一个原因，且这个值不能被改变。")])])])]),e._v(" "),r("p",[e._v("”值不能被改变”指的是其identity不能被改变，而不是指其成员内容不能被改变。")]),e._v(" "),r("h3",{attrs:{id:"_2-2-then-方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-then-方法"}},[e._v("#")]),e._v(" 2.2 "),r("code",[e._v("then")]),e._v(" 方法")]),e._v(" "),r("p",[e._v("一个Promise必须提供一个then方法来获取其值或原因。\nPromise的then方法接受两个参数：")]),e._v(" "),r("p",[e._v("promise.then(onFulfilled, onRejected)")]),e._v(" "),r("ol",[r("li",[r("p",[e._v("onFulfilled,onRejected 都是可选参数：")]),e._v(" "),r("ol",[r("li",[e._v("如果"),r("code",[e._v("onFulfilled")]),e._v("不是一个函数，则忽略之。")]),e._v(" "),r("li",[e._v("如果"),r("code",[e._v("onRejected")]),e._v("不是一个函数，则忽略之。")])])]),e._v(" "),r("li",[r("p",[e._v("如果onFulfilled是一个函数:")]),e._v(" "),r("ol",[r("li",[e._v("它必须在"),r("code",[e._v("promise")]),e._v(" fulfilled后调用， 且"),r("code",[e._v("promise")]),e._v("的value为其第一个参数。")]),e._v(" "),r("li",[e._v("它不能在"),r("code",[e._v("promise")]),e._v(" fulfilled前调用。")]),e._v(" "),r("li",[e._v("不能被多次调用。")])])]),e._v(" "),r("li",[r("p",[e._v("如果")])])]),e._v(" "),r("blockquote",[r("p",[e._v("onRejected是一个函数,")])]),e._v(" "),r("ol",[r("li",[r("p",[e._v("它必须在"),r("code",[e._v("promise")]),e._v(" rejected后调用， 且"),r("code",[e._v("promise")]),e._v("的reason为其第一个参数。")])]),e._v(" "),r("li",[r("p",[e._v("它不能在"),r("code",[e._v("promise")]),e._v(" rejected前调用。")])]),e._v(" "),r("li",[r("p",[e._v("不能被多次调用。")])]),e._v(" "),r("li",[r("p",[r("code",[e._v("onFulfilled")]),e._v(" 和 "),r("code",[e._v("onRejected")]),e._v(" 只允许在 "),r("a",{attrs:{href:"https://es5.github.io/#x10.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("execution context"),r("OutboundLink")],1),e._v(" 栈仅包含平台代码时运行. [3.1].")])]),e._v(" "),r("li",[r("p",[r("code",[e._v("onFulfilled")]),e._v(" 和 "),r("code",[e._v("onRejected")]),e._v(" 必须被当做函数调用 (i.e. 即函数体内的 "),r("code",[e._v("this")]),e._v(" 为"),r("code",[e._v("undefined")]),e._v("). [3.2]")])]),e._v(" "),r("li",[r("p",[e._v("对于一个")])])]),e._v(" "),r("blockquote",[r("p",[e._v("promise，它的then方法可以调用多次.")])]),e._v(" "),r("ol",[r("li",[r("p",[e._v("当"),r("code",[e._v("promise")]),e._v(" fulfilled后，所有"),r("code",[e._v("onFulfilled")]),e._v("都必须按照其注册顺序执行。")])]),e._v(" "),r("li",[r("p",[e._v("当"),r("code",[e._v("promise")]),e._v(" rejected后，所有"),r("code",[e._v("OnRejected")]),e._v("都必须按照其注册顺序执行。")])]),e._v(" "),r("li",[r("p",[r("code",[e._v("then")]),e._v(" 必须返回一个promise [3.3].")])])]),e._v(" "),r("blockquote",[r("p",[e._v("promise2 = promise1.then(onFulfilled, onRejected);")])]),e._v(" "),r("ol",[r("li",[e._v("如果"),r("code",[e._v("onFulfilled")]),e._v(" 或 "),r("code",[e._v("onRejected")]),e._v(" 返回了值"),r("code",[e._v("x")]),e._v(", 则执行Promise 解析流程"),r("code",[e._v("[[Resolve]](promise2, x)")]),e._v(".")]),e._v(" "),r("li",[e._v("如果"),r("code",[e._v("onFulfilled")]),e._v(" 或 "),r("code",[e._v("onRejected")]),e._v("抛出了异常"),r("code",[e._v("e")]),e._v(", 则"),r("code",[e._v("promise2")]),e._v("应当以"),r("code",[e._v("e")]),e._v("为"),r("code",[e._v("reason")]),e._v("被拒绝。")]),e._v(" "),r("li",[e._v("如果 "),r("code",[e._v("onFulfilled")]),e._v(" 不是一个函数且"),r("code",[e._v("promise1")]),e._v("已经fulfilled，则"),r("code",[e._v("promise2")]),e._v("必须以"),r("code",[e._v("promise1")]),e._v("的值fulfilled.")]),e._v(" "),r("li",[e._v("如果 "),r("code",[e._v("OnReject")]),e._v(" 不是一个函数且"),r("code",[e._v("promise1")]),e._v("已经rejected, 则"),r("code",[e._v("promise2")]),e._v("必须以相同的reason被拒绝.")])]),e._v(" "),r("h3",{attrs:{id:"_2-3-promise解析过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-promise解析过程"}},[e._v("#")]),e._v(" 2.3 Promise解析过程")]),e._v(" "),r("p",[r("strong",[e._v("Promise解析过程")]),e._v(" 是以一个promise和一个值做为参数的抽象过程，可表示为"),r("code",[e._v("[[Resolve]](promise, x)")]),e._v(". 过程如下；")]),e._v(" "),r("ol",[r("li",[r("p",[e._v("如果"),r("code",[e._v("promise")]),e._v(" 和 "),r("code",[e._v("x")]),e._v(" 指向相同的值, 使用 "),r("code",[e._v("TypeError")]),e._v("做为原因将"),r("code",[e._v("promise")]),e._v("拒绝。")])]),e._v(" "),r("li",[r("p",[e._v("如果"),r("code",[e._v("x")]),e._v(" 是一个"),r("code",[e._v("promise")]),e._v(", 采用其状态 [3.4 ]:")]),e._v(" "),r("ol",[r("li",[e._v("如果"),r("code",[e._v("x")]),e._v("是pending状态，"),r("code",[e._v("promise")]),e._v("必须保持pending走到"),r("code",[e._v("x")]),e._v(" fulfilled或rejected.")]),e._v(" "),r("li",[e._v("如果"),r("code",[e._v("x")]),e._v("是fulfilled状态，将"),r("code",[e._v("x")]),e._v("的值用于fulfill "),r("code",[e._v("promise")]),e._v(".")]),e._v(" "),r("li",[e._v("如果"),r("code",[e._v("x")]),e._v("是rejected状态, 将"),r("code",[e._v("x")]),e._v("的原因用于reject "),r("code",[e._v("promise")]),e._v("..")])])]),e._v(" "),r("li",[r("p",[e._v("如果"),r("code",[e._v("x")]),e._v("\n是一个对象或一个函数：")]),e._v(" "),r("ol",[r("li",[e._v("将 "),r("code",[e._v("then")]),e._v(" 赋为 "),r("code",[e._v("x.then")]),e._v(". [3.5]")]),e._v(" "),r("li",[e._v("如果在取"),r("code",[e._v("x.then")]),e._v("值时抛出了异常，则以这个异常做为原因将"),r("code",[e._v("promise")]),e._v("拒绝。")]),e._v(" "),r("li",[e._v("如果"),r("code",[e._v("then")]),e._v("是一个函数， 以"),r("code",[e._v("x")]),e._v("为"),r("code",[e._v("this")]),e._v("调用"),r("code",[e._v("then")]),e._v(" 函数， 且第一个参数是"),r("code",[e._v("resolvePromise")]),e._v("，第二个参数是"),r("code",[e._v("rejectPromise")]),e._v(" ，且：\n"),r("ol",[r("li",[e._v("当 "),r("code",[e._v("resolvePromise")]),e._v(" 被以 "),r("code",[e._v("y")]),e._v("为参数调用, 执行 "),r("code",[e._v("[[Resolve]](promise, y)")]),e._v(".")]),e._v(" "),r("li",[e._v("当 "),r("code",[e._v("rejectPromise")]),e._v(" 被以 "),r("code",[e._v("r")]),e._v(" 为参数调用, 则以"),r("code",[e._v("r")]),e._v("为原因将"),r("code",[e._v("promise")]),e._v("拒绝。")]),e._v(" "),r("li",[e._v("如果 "),r("code",[e._v("resolvePromise")]),e._v(" 和 "),r("code",[e._v("rejectPromise")]),e._v(" 都被调用了，或者被调用了多次，则只第一次有效，后面的忽略。")]),e._v(" "),r("li",[e._v("如果在调用"),r("code",[e._v("then")]),e._v(" 时抛出了异常，则：\n"),r("ol",[r("li",[e._v("如果 "),r("code",[e._v("resolvePromise")]),e._v(" 或 "),r("code",[e._v("rejectPromise")]),e._v(" 已经被调用了，则忽略它。")]),e._v(" "),r("li",[e._v("否则, 以"),r("code",[e._v("e")]),e._v("为reason将 "),r("code",[e._v("promise")]),e._v(" 拒绝。")])])])])]),e._v(" "),r("li",[e._v("如果 "),r("code",[e._v("then")]),e._v("不是一个函数，则 以"),r("code",[e._v("x")]),e._v("为值fulfill "),r("code",[e._v("promise")]),e._v("。")])])]),e._v(" "),r("li",[r("p",[e._v("如果 "),r("code",[e._v("x")]),e._v(" 不是对象也不是函数，则以"),r("code",[e._v("x")]),e._v("为值 fulfill "),r("code",[e._v("promise")]),e._v("。")])])]),e._v(" "),r("h2",{attrs:{id:"补充"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#补充"}},[e._v("#")]),e._v(" 补充")]),e._v(" "),r("p",[e._v("英文原文地址："),r("a",{attrs:{href:"http://promisesaplus.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://promisesaplus.com"),r("OutboundLink")],1),e._v("\n若要了解文中每一条规则，则参阅其测试仓库：https://github.com/promises-aplus/promises-tests/tree/master/lib/tests")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://segmentfault.com/a/1190000002452115",target:"_blank",rel:"noopener noreferrer"}},[e._v("原文"),r("OutboundLink")],1)]),e._v(" "),r("h1",{attrs:{id:"promise详解与实现-promise-a-规范"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise详解与实现-promise-a-规范"}},[e._v("#")]),e._v(" Promise详解与实现（Promise/A+规范）")]),e._v(" "),r("h3",{attrs:{id:"_1-什么是promise"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是promise"}},[e._v("#")]),e._v(" 1.什么是Promise?")]),e._v(" "),r("blockquote",[r("p",[e._v("Promise是JS异步编程中的重要概念，异步抽象处理对象，是目前比较流行Javascript异步编程解决方案之一")])]),e._v(" "),r("h3",{attrs:{id:"_2-对于几种常见异步编程方案"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-对于几种常见异步编程方案"}},[e._v("#")]),e._v(" 2.对于几种常见异步编程方案")]),e._v(" "),r("ul",[r("li",[e._v("回调函数")]),e._v(" "),r("li",[e._v("事件监听")]),e._v(" "),r("li",[e._v("发布/订阅")]),e._v(" "),r("li",[e._v("Promise对象")])]),e._v(" "),r("h4",{attrs:{id:"这里就拿回调函数说说"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#这里就拿回调函数说说"}},[e._v("#")]),e._v(" 这里就拿回调函数说说")]),e._v(" "),r("p",[e._v("1.对于回调函数 我们用Jquery的ajax获取数据时 都是以回调函数方式获取的数据")]),e._v(" "),r("div",{staticClass:"language-tsx extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("$.get(url, (data) => {\n    console.log(data)\n)\n")])])]),r("p",[e._v('2.如果说 当我们需要发送多个异步请求 并且每个请求之间需要相互依赖 那这时 我们只能 以嵌套方式来解决 形成 "回调地狱"')]),e._v(" "),r("div",{staticClass:"language-tsx extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("$.get(url, data1 => {\n    console.log(data1)\n    $.get(data1.url, data2 => {\n        console.log(data1)\n    })\n})\n")])])]),r("blockquote",[r("p",[e._v("这样一来，在处理越多的异步逻辑时，就需要越深的回调嵌套，这种编码模式的问题主要有以下几个：")])]),e._v(" "),r("ul",[r("li",[e._v("代码逻辑书写顺序与执行顺序不一致，不利于阅读与维护。")]),e._v(" "),r("li",[e._v("异步操作的顺序变更时，需要大规模的代码重构。")]),e._v(" "),r("li",[e._v("回调函数基本都是匿名函数，bug 追踪困难。")]),e._v(" "),r("li",[e._v("回调函数是被第三方库代码（如上例中的 ajax ）而非自己的业务代码所调用的，造成了 IoC 控制反转。")])]),e._v(" "),r("h4",{attrs:{id:"promise-处理多个相互关联的异步请求"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise-处理多个相互关联的异步请求"}},[e._v("#")]),e._v(" Promise 处理多个相互关联的异步请求")]),e._v(" "),r("p",[e._v('1.而我们Promise 可以更直观的方式 来解决 "回调地狱"')]),e._v(" "),r("div",{staticClass:"language-tsx extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const request = url => { \n    return new Promise((resolve, reject) => {\n        $.get(url, data => {\n            resolve(data)\n        });\n    })\n};\n\n// 请求data1\nrequest(url).then(data1 => {\n    return request(data1.url);   \n}).then(data2 => {\n    return request(data2.url);\n}).then(data3 => {\n    console.log(data3);\n}).catch(err => throw new Error(err));\n")])])]),r("p",[e._v("2.相信大家在 vue/react 都是用axios fetch 请求数据 也都支持 Promise API")]),e._v(" "),r("div",{staticClass:"language-jsx extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("import axios from 'axios';\naxios.get(url).then(data => {\n   console.log(data)\n})\n")])])]),r("blockquote",[r("p",[e._v("Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。")])]),e._v(" "),r("h3",{attrs:{id:"_3-promise使用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-promise使用"}},[e._v("#")]),e._v(" 3.Promise使用")]),e._v(" "),r("h4",{attrs:{id:"_1-promise-是一个构造函数-new-promise-返回一个-promise对象-接收一个excutor执行函数作为参数-excutor有两个函数类型形参resolve-reject"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-promise-是一个构造函数-new-promise-返回一个-promise对象-接收一个excutor执行函数作为参数-excutor有两个函数类型形参resolve-reject"}},[e._v("#")]),e._v(" 1.Promise 是一个构造函数， new Promise 返回一个 promise对象 接收一个excutor执行函数作为参数, excutor有两个函数类型形参resolve reject")]),e._v(" "),r("div",{staticClass:"language-jsx extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const promise = new Promise((resolve, reject) => {\n       // 异步处理\n       // 处理结束后、调用resolve 或 reject\n});\n")])])]),r("h4",{attrs:{id:"_2-promise相当于一个状态机"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-promise相当于一个状态机"}},[e._v("#")]),e._v(" 2.promise相当于一个状态机")]),e._v(" "),r("p",[e._v("promise的三种状态")]),e._v(" "),r("ul",[r("li",[e._v("pending")]),e._v(" "),r("li",[e._v("fulfilled")]),e._v(" "),r("li",[e._v("rejected")])]),e._v(" "),r("p",[e._v("1.promise 对象初始化状态为 pending\n2.当调用resolve(成功)，会由pending => fulfilled\n3.当调用reject(失败)，会由pending => rejected")]),e._v(" "),r("blockquote",[r("p",[e._v("注意promsie状态 只能由 pending => fulfilled/rejected, 一旦修改就不能再变")])]),e._v(" "),r("h4",{attrs:{id:"_3-promise对象方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-promise对象方法"}},[e._v("#")]),e._v(" 3.promise对象方法")]),e._v(" "),r("p",[e._v("1.then方法注册 当resolve(成功)/reject(失败)的回调函数")]),e._v(" "),r("div",{staticClass:"language-cpp extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// onFulfilled 是用来接收promise成功的值\n// onRejected 是用来接收promise失败的原因\npromise.then(onFulfilled, onRejected);\n")])])]),r("blockquote",[r("p",[e._v("then方法是异步执行的")])]),e._v(" "),r("p",[e._v("2.resolve(成功) onFulfilled会被调用")]),e._v(" "),r("div",{staticClass:"language-tsx extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const promise = new Promise((resolve, reject) => {\n   resolve('fulfilled'); // 状态由 pending => fulfilled\n});\npromise.then(result => { // onFulfilled\n    console.log(result); // 'fulfilled' \n}, reason => { // onRejected 不会被调用\n    \n})\n")])])]),r("p",[e._v("3.reject(失败) onRejected会被调用")]),e._v(" "),r("div",{staticClass:"language-tsx extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const promise = new Promise((resolve, reject) => {\n   reject('rejected'); // 状态由 pending => rejected\n});\npromise.then(result => { // onFulfilled 不会被调用\n  \n}, reason => { // onRejected \n    console.log(rejected); // 'rejected'\n})\n")])])]),r("p",[e._v("4.promise.catch")]),e._v(" "),r("blockquote",[r("p",[e._v("在链式写法中可以捕获前面then中发送的异常,")])]),e._v(" "),r("div",{staticClass:"language-csharp extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("promise.catch(onRejected)\n相当于\npromise.then(null, onRrejected);\n\n// 注意\n// onRejected 不能捕获当前onFulfilled中的异常\npromise.then(onFulfilled, onRrejected); \n\n// 可以写成：\npromise.then(onFulfilled)\n       .catch(onRrejected);   \n")])])]),r("h4",{attrs:{id:"_4-promise-chain"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-promise-chain"}},[e._v("#")]),e._v(" 4.promise chain")]),e._v(" "),r("blockquote",[r("p",[e._v("promise.then方法每次调用 都返回一个新的promise对象 所以可以链式写法")])]),e._v(" "),r("div",{staticClass:"language-jsx extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('function taskA() {\n    console.log("Task A");\n}\nfunction taskB() {\n    console.log("Task B");\n}\nfunction onRejected(error) {\n    console.log("Catch Error: A or B", error);\n}\n\nvar promise = Promise.resolve();\npromise\n    .then(taskA)\n    .then(taskB)\n    .catch(onRejected) // 捕获前面then方法中的异常\n')])])]),r("h4",{attrs:{id:"_5-promise的静态方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-promise的静态方法"}},[e._v("#")]),e._v(" 5.Promise的静态方法")]),e._v(" "),r("p",[e._v("1.Promise.resolve 返回一个fulfilled状态的promise对象")]),e._v(" "),r("div",{staticClass:"language-jsx extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("Promise.resolve('hello').then(function(value){\n    console.log(value);\n});\n\nPromise.resolve('hello');\n// 相当于\nconst promise = new Promise(resolve => {\n   resolve('hello');\n});\n")])])]),r("p",[e._v("2.Promise.reject 返回一个rejected状态的promise对象")]),e._v(" "),r("div",{staticClass:"language-jsx extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("Promise.reject(24);\nnew Promise((resolve, reject) => {\n   reject(24);\n});\n")])])]),r("p",[e._v("3.Promise.all 接收一个promise对象数组为参数")]),e._v(" "),r("blockquote",[r("p",[e._v("只有全部为resolve才会调用 通常会用来处理 多个并行异步操作")])]),e._v(" "),r("div",{staticClass:"language-tsx extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const p1 = new Promise((resolve, reject) => {\n    resolve(1);\n});\n\nconst p2 = new Promise((resolve, reject) => {\n    resolve(2);\n});\n\nconst p3 = new Promise((resolve, reject) => {\n    reject(3);\n});\n\nPromise.all([p1, p2, p3]).then(data => { \n    console.log(data); // [1, 2, 3] 结果顺序和promise实例数组顺序是一致的\n}, err => {\n    console.log(err);\n});\n")])])]),r("p",[e._v("4.Promise.race 接收一个promise对象数组为参数")]),e._v(" "),r("blockquote",[r("p",[e._v("Promise.race 只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理。")])]),e._v(" "),r("div",{staticClass:"language-jsx extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("function timerPromisefy(delay) {\n    return new Promise(function (resolve, reject) {\n        setTimeout(function () {\n            resolve(delay);\n        }, delay);\n    });\n}\nvar startDate = Date.now();\n\nPromise.race([\n    timerPromisefy(10),\n    timerPromisefy(20),\n    timerPromisefy(30)\n]).then(function (values) {\n    console.log(values); // 10\n});\n")])])]),r("h3",{attrs:{id:"_4-promise-代码实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-promise-代码实现"}},[e._v("#")]),e._v(" 4. Promise 代码实现")]),e._v(" "),r("div",{staticClass:"language-jsx extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("/**\n * Promise 实现 遵循promise/A+规范\n * Promise/A+规范译文:\n * https://malcolmyu.github.io/2015/06/12/Promises-A-Plus/#note-4\n */\n\n// promise 三个状态\nconst PENDING = \"pending\";\nconst FULFILLED = \"fulfilled\";\nconst REJECTED = \"rejected\";\n\nfunction Promise(excutor) {\n    let that = this; // 缓存当前promise实例对象\n    that.status = PENDING; // 初始状态\n    that.value = undefined; // fulfilled状态时 返回的信息\n    that.reason = undefined; // rejected状态时 拒绝的原因\n    that.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数\n    that.onRejectedCallbacks = []; // 存储rejected状态对应的onRejected函数\n\n    function resolve(value) { // value成功态时接收的终值\n        if(value instanceof Promise) {\n            return value.then(resolve, reject);\n        }\n\n        // 为什么resolve 加setTimeout?\n        // 2.2.4规范 onFulfilled 和 onRejected 只允许在 execution context 栈仅包含平台代码时运行.\n        // 注1 这里的平台代码指的是引擎、环境以及 promise 的实施代码。实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。\n\n        setTimeout(() => {\n            // 调用resolve 回调对应onFulfilled函数\n            if (that.status === PENDING) {\n                // 只能由pedning状态 => fulfilled状态 (避免调用多次resolve reject)\n                that.status = FULFILLED;\n                that.value = value;\n                that.onFulfilledCallbacks.forEach(cb => cb(that.value));\n            }\n        });\n    }\n\n    function reject(reason) { // reason失败态时接收的拒因\n        setTimeout(() => {\n            // 调用reject 回调对应onRejected函数\n            if (that.status === PENDING) {\n                // 只能由pedning状态 => rejected状态 (避免调用多次resolve reject)\n                that.status = REJECTED;\n                that.reason = reason;\n                that.onRejectedCallbacks.forEach(cb => cb(that.reason));\n            }\n        });\n    }\n\n    // 捕获在excutor执行器中抛出的异常\n    // new Promise((resolve, reject) => {\n    //     throw new Error('error in excutor')\n    // })\n    try {\n        excutor(resolve, reject);\n    } catch (e) {\n        reject(e);\n    }\n}\n\n/**\n * resolve中的值几种情况：\n * 1.普通值\n * 2.promise对象\n * 3.thenable对象/函数\n */\n\n/**\n * 对resolve 进行改造增强 针对resolve中不同值情况 进行处理\n * @param  {promise} promise2 promise1.then方法返回的新的promise对象\n * @param  {[type]} x         promise1中onFulfilled的返回值\n * @param  {[type]} resolve   promise2的resolve方法\n * @param  {[type]} reject    promise2的reject方法\n */\nfunction resolvePromise(promise2, x, resolve, reject) {\n    if (promise2 === x) {  // 如果从onFulfilled中返回的x 就是promise2 就会导致循环引用报错\n        return reject(new TypeError('循环引用'));\n    }\n\n    let called = false; // 避免多次调用\n    // 如果x是一个promise对象 （该判断和下面 判断是不是thenable对象重复 所以可有可无）\n    if (x instanceof Promise) { // 获得它的终值 继续resolve\n        if (x.status === PENDING) { // 如果为等待态需等待直至 x 被执行或拒绝 并解析y值\n            x.then(y => {\n                resolvePromise(promise2, y, resolve, reject);\n            }, reason => {\n                reject(reason);\n            });\n        } else { // 如果 x 已经处于执行态/拒绝态(值已经被解析为普通值)，用相同的值执行传递下去 promise\n            x.then(resolve, reject);\n        }\n        // 如果 x 为对象或者函数\n    } else if (x != null && ((typeof x === 'object') || (typeof x === 'function'))) {\n        try { // 是否是thenable对象（具有then方法的对象/函数）\n            let then = x.then;\n            if (typeof then === 'function') {\n                then.call(x, y => {\n                    if(called) return;\n                    called = true;\n                    resolvePromise(promise2, y, resolve, reject);\n                }, reason => {\n                    if(called) return;\n                    called = true;\n                    reject(reason);\n                })\n            } else { // 说明是一个普通对象/函数\n                resolve(x);\n            }\n        } catch(e) {\n            if(called) return;\n            called = true;\n            reject(e);\n        }\n    } else {\n        resolve(x);\n    }\n}\n\n/**\n * [注册fulfilled状态/rejected状态对应的回调函数]\n * @param  {function} onFulfilled fulfilled状态时 执行的函数\n * @param  {function} onRejected  rejected状态时 执行的函数\n * @return {function} newPromsie  返回一个新的promise对象\n */\nPromise.prototype.then = function(onFulfilled, onRejected) {\n    const that = this;\n    let newPromise;\n    // 处理参数默认值 保证参数后续能够继续执行\n    onFulfilled =\n        typeof onFulfilled === \"function\" ? onFulfilled : value => value;\n    onRejected =\n        typeof onRejected === \"function\" ? onRejected : reason => {\n            throw reason;\n        };\n\n    // then里面的FULFILLED/REJECTED状态时 为什么要加setTimeout ?\n    // 原因:\n    // 其一 2.2.4规范 要确保 onFulfilled 和 onRejected 方法异步执行(且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行) 所以要在resolve里加上setTimeout\n    // 其二 2.2.6规范 对于一个promise，它的then方法可以调用多次.（当在其他程序中多次调用同一个promise的then时 由于之前状态已经为FULFILLED/REJECTED状态，则会走的下面逻辑),所以要确保为FULFILLED/REJECTED状态后 也要异步执行onFulfilled/onRejected\n\n    // 其二 2.2.6规范 也是resolve函数里加setTimeout的原因\n    // 总之都是 让then方法异步执行 也就是确保onFulfilled/onRejected异步执行\n\n    // 如下面这种情景 多次调用p1.then\n    // p1.then((value) => { // 此时p1.status 由pedding状态 => fulfilled状态\n    //     console.log(value); // resolve\n    //     // console.log(p1.status); // fulfilled\n    //     p1.then(value => { // 再次p1.then 这时已经为fulfilled状态 走的是fulfilled状态判断里的逻辑 所以我们也要确保判断里面onFuilled异步执行\n    //         console.log(value); // 'resolve'\n    //     });\n    //     console.log('当前执行栈中同步代码');\n    // })\n    // console.log('全局执行栈中同步代码');\n    //\n\n    if (that.status === FULFILLED) { // 成功态\n        return newPromise = new Promise((resolve, reject) => {\n            setTimeout(() => {\n                try{\n                    let x = onFulfilled(that.value);\n                    resolvePromise(newPromise, x, resolve, reject); // 新的promise resolve 上一个onFulfilled的返回值\n                } catch(e) {\n                    reject(e); // 捕获前面onFulfilled中抛出的异常 then(onFulfilled, onRejected);\n                }\n            });\n        })\n    }\n\n    if (that.status === REJECTED) { // 失败态\n        return newPromise = new Promise((resolve, reject) => {\n            setTimeout(() => {\n                try {\n                    let x = onRejected(that.reason);\n                    resolvePromise(newPromise, x, resolve, reject);\n                } catch(e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n\n    if (that.status === PENDING) { // 等待态\n        // 当异步调用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中\n        return newPromise = new Promise((resolve, reject) => {\n            that.onFulfilledCallbacks.push((value) => {\n                try {\n                    let x = onFulfilled(value);\n                    resolvePromise(newPromise, x, resolve, reject);\n                } catch(e) {\n                    reject(e);\n                }\n            });\n            that.onRejectedCallbacks.push((reason) => {\n                try {\n                    let x = onRejected(reason);\n                    resolvePromise(newPromise, x, resolve, reject);\n                } catch(e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n};\n\n/**\n * Promise.all Promise进行并行处理\n * 参数: promise对象组成的数组作为参数\n * 返回值: 返回一个Promise实例\n * 当这个数组里的所有promise对象全部变为resolve状态的时候，才会resolve。\n */\nPromise.all = function(promises) {\n    return new Promise((resolve, reject) => {\n        let done = gen(promises.length, resolve);\n        promises.forEach((promise, index) => {\n            promise.then((value) => {\n                done(index, value)\n            }, reject)\n        })\n    })\n}\n\nfunction gen(length, resolve) {\n    let count = 0;\n    let values = [];\n    return function(i, value) {\n        values[i] = value;\n        if (++count === length) {\n            console.log(values);\n            resolve(values);\n        }\n    }\n}\n\n/**\n * Promise.race\n * 参数: 接收 promise对象组成的数组作为参数\n * 返回值: 返回一个Promise实例\n * 只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理(取决于哪一个更快)\n */\nPromise.race = function(promises) {\n    return new Promise((resolve, reject) => {\n        promises.forEach((promise, index) => {\n           promise.then(resolve, reject);\n        });\n    });\n}\n\n// 用于promise方法链时 捕获前面onFulfilled/onRejected抛出的异常\nPromise.prototype.catch = function(onRejected) {\n    return this.then(null, onRejected);\n}\n\nPromise.resolve = function (value) {\n    return new Promise(resolve => {\n        resolve(value);\n    });\n}\n\nPromise.reject = function (reason) {\n    return new Promise((resolve, reject) => {\n        reject(reason);\n    });\n}\n\n/**\n * 基于Promise实现Deferred的\n * Deferred和Promise的关系\n * - Deferred 拥有 Promise\n * - Deferred 具备对 Promise的状态进行操作的特权方法（resolve reject）\n *\n *参考jQuery.Deferred\n *url: http://api.jquery.com/category/deferred-object/\n */\nPromise.deferred = function() { // 延迟对象\n    let defer = {};\n    defer.promise = new Promise((resolve, reject) => {\n        defer.resolve = resolve;\n        defer.reject = reject;\n    });\n    return defer;\n}\n\n/**\n * Promise/A+规范测试\n * npm i -g promises-aplus-tests\n * promises-aplus-tests Promise.js\n */\n\ntry {\n  module.exports = Promise\n} \ncatch (e) {\n}\n")])])]),r("h3",{attrs:{id:"_5-promise测试"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-promise测试"}},[e._v("#")]),e._v(" 5. Promise测试")]),e._v(" "),r("div",{staticClass:"language-css extra-class"},[r("pre",{pre:!0,attrs:{class:"language-css"}},[r("code",[e._v("npm i -g promises-aplus-tests\npromises-aplus-tests Promise.js\n")])])]),r("h3",{attrs:{id:"_6-相关知识参考资料"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-相关知识参考资料"}},[e._v("#")]),e._v(" 6. 相关知识参考资料")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://link.jianshu.com?t=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fpromise",target:"_blank",rel:"noopener noreferrer"}},[e._v("ES6-promise"),r("OutboundLink")],1),e._v(" "),r("a",{attrs:{href:"https://link.jianshu.com?t=https%3A%2F%2Fpromisesaplus.com%2F",target:"_blank",rel:"noopener noreferrer"}},[e._v("Promises/A+规范-英文"),r("OutboundLink")],1),e._v(" "),r("a",{attrs:{href:"https://link.jianshu.com?t=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000002452115",target:"_blank",rel:"noopener noreferrer"}},[e._v("Promises/A+规范-翻译1"),r("OutboundLink")],1),e._v(" "),r("a",{attrs:{href:"https://link.jianshu.com?t=https%3A%2F%2Fmalcolmyu.github.io%2F2015%2F06%2F12%2FPromises-A-Plus%2F%23note-4",target:"_blank",rel:"noopener noreferrer"}},[e._v("Promises/A+规范-翻译-推荐"),r("OutboundLink")],1),e._v(" "),r("a",{attrs:{href:"https://link.jianshu.com?t=https%3A%2F%2Fwww.cnblogs.com%2Fmqliutie%2Fp%2F4422247.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("JS执行栈"),r("OutboundLink")],1),e._v(" "),r("a",{attrs:{href:"https://link.jianshu.com?t=http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2012%2F12%2Fasynchronous%EF%BC%BFjavascript.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Javascript异步编程的4种方法"),r("OutboundLink")],1)]),e._v(" "),r("p",[e._v("链接：https://www.jianshu.com/p/459a856c476f\n来源：简书")])])}),[],!1,null,null,null);n.default=o.exports}}]);