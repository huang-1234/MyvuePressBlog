(window.webpackJsonp=window.webpackJsonp||[]).push([[459],{970:function(e,t,a){"use strict";a.r(t);var n=a(6),v=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"vue变化侦测原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue变化侦测原理"}},[e._v("#")]),e._v(" vue变化侦测原理")]),e._v(" "),a("p",[e._v("关于vue的内部原理其实有很多个重要的部分，变化侦测，模板编译，virtualDOM，整体运行流程等。")]),e._v(" "),a("p",[e._v("今天主要把变化侦测这部分单独拿出来讲一讲。")]),e._v(" "),a("h2",{attrs:{id:"如何侦测变化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何侦测变化"}},[e._v("#")]),e._v(" 如何侦测变化？")]),e._v(" "),a("p",[e._v("关于变化侦测首先要问一个问题，在 js 中，如何侦测一个对象的变化，其实这个问题还是比较简单的，学过js的都能知道，js中有两种方法可以侦测到变化，"),a("code",[e._v("Object.defineProperty")]),e._v(" 和 ES6 的"),a("code",[e._v("proxy")]),e._v("。")]),e._v(" "),a("p",[e._v("到目前为止vue还是用的 "),a("code",[e._v("Object.defineProperty")]),e._v("，所以我们拿 "),a("code",[e._v("Object.defineProperty")]),e._v("来举例子说明这个原理。")]),e._v(" "),a("p",[e._v("这里我想说的是，不管以后vue是否会用 "),a("code",[e._v("proxy")]),e._v(" 重写这部分，我讲的是原理，并不是api，所以不论以后vue会怎样改，这个原理是不会变的，哪怕vue用了其他完全不同的原理实现了变化侦测，但是本篇文章讲的原理一样可以实现变化侦测，原理这个东西是不会过时的。")]),e._v(" "),a("p",[e._v("之前我写文章有一个毛病就是喜欢对着源码翻译，结果过了半年一年人家源码改了，我写的文章就一毛钱都不值了，而且对着源码翻译还有一个缺点是对读者的要求有点偏高，读者如果没看过源码或者看的和我不是一个版本，那根本就不知道我在说什么。")]),e._v(" "),a("p",[e._v("好了不说废话了，继续讲刚才的内容。")]),e._v(" "),a("p",[e._v("知道 "),a("code",[e._v("Object.defineProperty")]),e._v(" 可以侦测到对象的变化，那么我们瞬间可以写出这样的代码：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function defineReactive (data, key, val) {\n    Object.defineProperty(data, key, {\n        enumerable: true,\n        configurable: true,\n        get: function () {\n            return val\n        },\n        set: function (newVal) {\n            if(val === newVal){\n                return\n            }\n            val = newVal\n        }\n    })\n}\n")])])]),a("p",[e._v("写一个函数封装一下 "),a("code",[e._v("Object.defineProperty")]),e._v("，毕竟 "),a("code",[e._v("Object.defineProperty")]),e._v("的用法这么复杂，封装一下我只需要传递一个 data，和 key，val 就行了。")]),e._v(" "),a("p",[e._v("现在封装好了之后每当 "),a("code",[e._v("data")]),e._v(" 的 "),a("code",[e._v("key")]),e._v(" 读取数据 "),a("code",[e._v("get")]),e._v(" 这个函数可以被触发，设置数据的时候 "),a("code",[e._v("set")]),e._v(" 这个函数可以被触发，但是，，，，，，，，，，，，，，，，，，发现好像并没什么鸟用？")]),e._v(" "),a("h2",{attrs:{id:"怎么观察"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#怎么观察"}},[e._v("#")]),e._v(" 怎么观察？")]),e._v(" "),a("p",[e._v("现在我要问第二个问题，“怎么观察？”")]),e._v(" "),a("p",[e._v("思考一下，我们之所以要观察一个数据，目的是为了当数据的属性发生变化时，可以通知那些使用了这个 "),a("code",[e._v("key")]),e._v(" 的地方。")]),e._v(" "),a("p",[e._v("举个🌰：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("<template>\n  <div>{{ key }}</div>\n  <p>{{ key }}</p>\n</template>\n")])])]),a("p",[e._v("模板中有两处使用了 "),a("code",[e._v("key")]),e._v("，所以当数据发生变化时，要把这两处都通知到。")]),e._v(" "),a("p",[e._v("所以上面的问题，我的回答是，先收集依赖，把这些使用到 "),a("code",[e._v("key")]),e._v(" 的地方先收集起来，然后等属性发生变化时，把收集好的依赖循环触发一遍就好了~")]),e._v(" "),a("p",[e._v("总结起来其实就一句话，"),a("strong",[e._v("getter中，收集依赖，setter中，触发依赖")]),e._v("。")]),e._v(" "),a("h2",{attrs:{id:"依赖收集在哪"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#依赖收集在哪"}},[e._v("#")]),e._v(" 依赖收集在哪？")]),e._v(" "),a("p",[e._v("现在我们已经有了很明确的目标，就是要在getter中收集依赖，那么我们的依赖收集到哪里去呢？？")]),e._v(" "),a("p",[e._v("思考一下，首先想到的是每个 "),a("code",[e._v("key")]),e._v(" 都有一个数组，用来存储当前 "),a("code",[e._v("key")]),e._v(" 的依赖，假设依赖是一个函数存在 "),a("code",[e._v("window.target")]),e._v(" 上，先把 "),a("code",[e._v("defineReactive")]),e._v(" 稍微改造一下：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function defineReactive (data, key, val) {\n    let dep = [] // 新增\n    Object.defineProperty(data, key, {\n        enumerable: true,\n        configurable: true,\n        get: function () {\n            dep.push(window.target) // 新增\n            return val\n        },\n        set: function (newVal) {\n            if(val === newVal){\n                return\n            }\n            \n            // 新增\n            for (let i = 0; i < dep.length; i++) {\n            \t dep[i](newVal, val)\n            }\n            val = newVal\n        }\n    })\n}\n")])])]),a("p",[e._v("在 "),a("code",[e._v("defineReactive")]),e._v(" 中新增了数组 dep，用来存储被收集的依赖。")]),e._v(" "),a("p",[e._v("然后在触发 set 触发时，循环dep把收集到的依赖触发。")]),e._v(" "),a("p",[e._v("但是这样写有点耦合，我们把依赖收集这部分代码封装起来，写成下面的样子：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("export default class Dep {\n  static target: ?Watcher;\n  id: number;\n  subs: Array<Watcher>;\n\n  constructor () {\n    this.id = uid++\n    this.subs = []\n  }\n\n  addSub (sub: Watcher) {\n    this.subs.push(sub)\n  }\n\n  removeSub (sub: Watcher) {\n    remove(this.subs, sub)\n  }\n\n  depend () {\n    if (Dep.target) {\n      this.addSub(Dep.target)\n    }\n  }\n\n  notify () {\n    // stabilize the subscriber list first\n    const subs = this.subs.slice()\n    for (let i = 0, l = subs.length; i < l; i++) {\n      subs[i].update()\n    }\n  }\n}\n")])])]),a("p",[e._v("然后在改造一下 "),a("code",[e._v("defineReactive")]),e._v("：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function defineReactive (data, key, val) {\n    let dep = new Dep()        // 修改\n    Object.defineProperty(data, key, {\n        enumerable: true,\n        configurable: true,\n        get: function () {\n            dep.depend() // 修改\n            return val\n        },\n        set: function (newVal) {\n            if(val === newVal){\n                return\n            }\n\n            dep.notify() // 新增\n            val = newVal\n        }\n    })\n}\n")])])]),a("p",[e._v("这一次代码看起来清晰多了，顺便回答一下上面问的问题，依赖收集到哪？收集到Dep中，Dep是专门用来存储依赖的。")]),e._v(" "),a("h2",{attrs:{id:"收集谁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#收集谁"}},[e._v("#")]),e._v(" 收集谁？")]),e._v(" "),a("p",[e._v("上面我们假装 "),a("code",[e._v("window.target")]),e._v(" 是需要被收集的依赖，细心的同学可能已经看到，上面的代码 "),a("code",[e._v("window.target")]),e._v(" 已经改成了 "),a("code",[e._v("Dep.target")]),e._v("，那 "),a("code",[e._v("Dep.target")]),e._v("是什么？我们究竟要收集谁呢？？")]),e._v(" "),a("p",[e._v("收集谁，换句话说是当属性发生变化后，通知谁。")]),e._v(" "),a("p",[e._v("我们要通知那个使用到数据的地方，而使用这个数据的地方有很多，而且类型还不一样，有可能是模板，有可能是用户写的一个 watch，所以这个时候我们需要抽象出一个能集中处理这些不同情况的类，然后我们在依赖收集的阶段只收集这个封装好的类的实例进来，通知也只通知它一个，然后它在负责通知其他地方，所以我们要抽象的这个东西需要先起一个好听的名字，嗯，就叫它watcher吧~")]),e._v(" "),a("p",[e._v("所以现在可以回答上面的问题，收集谁？？收集 Watcher。")]),e._v(" "),a("h2",{attrs:{id:"什么是watcher"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是watcher"}},[e._v("#")]),e._v(" 什么是Watcher？")]),e._v(" "),a("p",[e._v("watcher 是一个中介的角色，数据发生变化通知给 watcher，然后watcher在通知给其他地方。")]),e._v(" "),a("p",[e._v("关于watcher我们先看一个经典的使用方式：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// keypath\nvm.$watch('a.b.c', function (newVal, oldVal) {\n  // do something\n})\n")])])]),a("p",[e._v("这段代码表示当 "),a("code",[e._v("data.a.b.c")]),e._v(" 这个属性发生变化时，触发第二个参数这个函数。")]),e._v(" "),a("p",[e._v("思考一下怎么实现这个功能呢？")]),e._v(" "),a("p",[e._v("好像只要把这个 watcher 实例添加到 "),a("code",[e._v("data.a.b.c")]),e._v(" 这个属性的 Dep 中去就行了，然后 "),a("code",[e._v("data.a.b.c")]),e._v(" 触发时，会通知到watcher，然后watcher在执行参数中的这个回调函数。")]),e._v(" "),a("p",[e._v("好，思考完毕，开工，写出如下代码：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("class Watch {\n    constructor (expOrFn, cb) {\n        // 执行 this.getter() 就可以拿到 data.a.b.c\n        this.getter = parsePath(expOrFn)\n        this.cb = cb\n        this.value = this.get()\n    }\n\n    get () {\n        Dep.target = this\n        value = this.getter.call(vm, vm)\n        Dep.target = undefined\n    }\n\n    update () {\n        const oldValue = this.value\n        this.value = this.get()\n        this.cb.call(this.vm, this.value, oldValue)\n    }\n}\n")])])]),a("p",[e._v("这段代码可以把自己主动 "),a("code",[e._v("push")]),e._v(" 到 "),a("code",[e._v("data.a.b.c")]),e._v(" 的 Dep 中去。")]),e._v(" "),a("p",[e._v("因为我在 "),a("code",[e._v("get")]),e._v(" 这个方法中，先把 Dep.traget 设置成了 "),a("code",[e._v("this")]),e._v("，也就是当前watcher实例，然后在读一下 "),a("code",[e._v("data.a.b.c")]),e._v(" 的值。")]),e._v(" "),a("p",[e._v("因为读了 "),a("code",[e._v("data.a.b.c")]),e._v(" 的值，所以肯定会触发 "),a("code",[e._v("getter")]),e._v("。")]),e._v(" "),a("p",[e._v("触发了 "),a("code",[e._v("getter")]),e._v(" 上面我们封装的 "),a("code",[e._v("defineReactive")]),e._v("函数中有一段逻辑就会从 "),a("code",[e._v("Dep.target")]),e._v(" 里读一个依赖 "),a("code",[e._v("push")]),e._v(" 到 "),a("code",[e._v("Dep")]),e._v(" 中。")]),e._v(" "),a("p",[e._v("所以就导致，我只要先在 Dep.target 赋一个 "),a("code",[e._v("this")]),e._v("，然后我在读一下值，去触发一下 "),a("code",[e._v("getter")]),e._v("，就可以把 "),a("code",[e._v("this")]),e._v(" 主动 "),a("code",[e._v("push")]),e._v(" 到 "),a("code",[e._v("keypath")]),e._v(" 的依赖中，有没有很神奇~")]),e._v(" "),a("p",[e._v("依赖注入到 "),a("code",[e._v("Dep")]),e._v(" 中去之后，当这个 "),a("code",[e._v("data.a.b.c")]),e._v(" 的值发生变化，就把所有的依赖循环触发 update 方法，也就是上面代码中 update 那个方法。")]),e._v(" "),a("p",[a("code",[e._v("update")]),e._v(" 方法会触发参数中的回调函数，将value 和 oldValue 传到参数中。")]),e._v(" "),a("p",[e._v("所以其实不管是用户执行的 "),a("code",[e._v("vm.$watch('a.b.c', (value, oldValue) => {})")]),e._v(" 还是模板中用到的data，都是通过 watcher 来通知自己是否需要发生变化的。")]),e._v(" "),a("h2",{attrs:{id:"递归侦测所有key"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#递归侦测所有key"}},[e._v("#")]),e._v(" 递归侦测所有key")]),e._v(" "),a("p",[e._v("现在其实已经可以实现变化侦测的功能了，但是我们之前写的代码只能侦测数据中的一个 key，所以我们要加工一下 "),a("code",[e._v("defineReactive")]),e._v(" 这个函数：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 新增\nfunction walk (obj: Object) {\n  const keys = Object.keys(obj)\n  for (let i = 0; i < keys.length; i++) {\n    defineReactive(obj, keys[i], obj[keys[i]])\n  }\n}\n\nfunction defineReactive (data, key, val) {\n    walk(val) // 新增\n    let dep = new Dep()\n    Object.defineProperty(data, key, {\n        enumerable: true,\n        configurable: true,\n        get: function () {\n            dep.depend()\n            return val\n        },\n        set: function (newVal) {\n            if(val === newVal){\n                return\n            }\n\n            dep.notify()\n            val = newVal\n        }\n    })\n}\n")])])]),a("p",[e._v("这样我们就可以通过执行 "),a("code",[e._v("walk(data)")]),e._v("，把 "),a("code",[e._v("data")]),e._v(" 中的所有 "),a("code",[e._v("key")]),e._v(" 都加工成可以被侦测的，因为是一个递归的过程，所以 "),a("code",[e._v("key")]),e._v(" 中的 "),a("code",[e._v("value")]),e._v(" 如果是一个对象，那这个对象的所有key也会被侦测。")]),e._v(" "),a("h2",{attrs:{id:"array怎么进行变化侦测"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#array怎么进行变化侦测"}},[e._v("#")]),e._v(" Array怎么进行变化侦测？")]),e._v(" "),a("p",[e._v("现在又发现了新的问题，"),a("code",[e._v("data")]),e._v(" 中不是所有的 "),a("code",[e._v("value")]),e._v(" 都是对象和基本类型，如果是一个数组怎么办？？数组是没有办法通过 "),a("code",[e._v("Object.defineProperty")]),e._v(" 来侦测到行为的。")]),e._v(" "),a("p",[e._v("vue 中对这个数组问题的解决方案非常的简单粗暴，我说说vue是如何实现的，大体上分三步：")]),e._v(" "),a("p",[e._v("第一步：先把原生 "),a("code",[e._v("Array")]),e._v(" 的原型方法继承下来。")]),e._v(" "),a("p",[e._v("第二步：对继承后的对象使用 "),a("code",[e._v("Object.defineProperty")]),e._v(" 做一些拦截操作。")]),e._v(" "),a("p",[e._v("第三步：把加工后可以被拦截的原型，赋值到需要被拦截的 "),a("code",[e._v("Array")]),e._v(" 类型的数据的原型上。")]),e._v(" "),a("p",[a("strong",[e._v("vue的实现")])]),e._v(" "),a("p",[e._v("第一步：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const arrayProto = Array.prototype\nexport const arrayMethods = Object.create(arrayProto)\n")])])]),a("p",[e._v("第二步：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(";[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  const original = arrayProto[method]\n\n  Object.defineProperty(arrayMethods, method, {\n    value: function mutator (...args) {\n      console.log(method) // 打印数组方法\n      return original.apply(this, args)\n    },\n    enumerable: false,\n    writable: true,\n    configurable: true\n  })\n})\n")])])]),a("p",[e._v("现在可以看到，每当被侦测的 "),a("code",[e._v("array")]),e._v(" 执行方法操作数组时，我都可以知道他执行的方法是什么，并且打印到 "),a("code",[e._v("console")]),e._v(" 中。")]),e._v(" "),a("p",[e._v("现在我要对这个数组方法类型进行判断，如果操作数组的方法是 push unshift splice （这种可以新增数组元素的方法），需要把新增的元素用上面封装的 "),a("code",[e._v("walk")]),e._v(" 来进行变化检测。")]),e._v(" "),a("p",[e._v("并且不论操作数组的是什么方法，我都要触发消息，通知依赖列表中的依赖数据发生了变化。")]),e._v(" "),a("p",[e._v("那现在怎么访问依赖列表呢，可能我们需要把上面封装的 "),a("code",[e._v("walk")]),e._v(" 加工一下：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 工具函数\nfunction def (obj: Object, key: string, val: any, enumerable?: boolean) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  })\n}\n\nexport class Observer {\n  value: any;\n  dep: Dep;\n  vmCount: number; // number of vms that has this object as root $data\n\n  constructor (value: any) {\n    this.value = value\n    this.dep = new Dep() // 新增\n    this.vmCount = 0\n    def(value, '__ob__', this) // 新增\n\n    // 新增\n    if (Array.isArray(value)) {\n      this.observeArray(value)\n    } else {\n      this.walk(value)\n    }\n  }\n\n  /**\n   * Walk through each property and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  walk (obj: Object) {\n    const keys = Object.keys(obj)\n    for (let i = 0; i < keys.length; i++) {\n      defineReactive(obj, keys[i], obj[keys[i]])\n    }\n  }\n\n  /**\n   * Observe a list of Array items.\n   */\n  observeArray (items: Array<any>) {\n    for (let i = 0, l = items.length; i < l; i++) {\n      new Observer(items[i])\n    }\n  }\n}\n")])])]),a("p",[e._v("我们定义了一个 "),a("code",[e._v("Observer")]),e._v(" 类，他的职责是将 "),a("code",[e._v("data")]),e._v(" 转换成可以被侦测到变化的 "),a("code",[e._v("data")]),e._v("，并且新增了对类型的判断，如果是 "),a("code",[e._v("value")]),e._v(" 的类型是 "),a("code",[e._v("Array")]),e._v(" 循环 Array将每一个元素丢到 Observer 中。")]),e._v(" "),a("p",[e._v("并且在 value 上做了一个标记 "),a("code",[e._v("__ob__")]),e._v("，这样我们就可以通过 "),a("code",[e._v("value")]),e._v(" 的 "),a("code",[e._v("__ob__")]),e._v(" 拿到Observer实例，然后使用 "),a("code",[e._v("__ob__")]),e._v(" 上的 "),a("code",[e._v("dep.notify()")]),e._v(" 就可以发送通知啦。")]),e._v(" "),a("p",[e._v("然后我们在改进一下Array原型的拦截器：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(";[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  const original = arrayProto[method]\n  def(arrayMethods, method, function mutator (...args) {\n    const result = original.apply(this, args)\n    const ob = this.__ob__\n    let inserted\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args\n        break\n      case 'splice':\n        inserted = args.slice(2)\n        break\n    }\n    if (inserted) ob.observeArray(inserted)\n    // notify change\n    ob.dep.notify()\n    return result\n  })\n})\n")])])]),a("p",[e._v("可以看到写了一个 "),a("code",[e._v("switch")]),e._v(" 对 "),a("code",[e._v("method")]),e._v(" 进行判断，如果是 "),a("code",[e._v("push")]),e._v("，"),a("code",[e._v("unshift")]),e._v("，"),a("code",[e._v("splice")]),e._v(" 这种可以新增数组元素的方法就使用 "),a("code",[e._v("ob.observeArray(inserted)")]),e._v(" 把新增的元素也丢到 "),a("code",[e._v("Observer")]),e._v(" 中去转换成可以被侦测到变化的数据。")]),e._v(" "),a("p",[e._v("在最后不论操作数组的方法是什么，都会调用 "),a("code",[e._v("ob.dep.notify()")]),e._v(" 去通知 "),a("code",[e._v("watcher")]),e._v(" 数据发生了改变。")]),e._v(" "),a("h2",{attrs:{id:"arraymethods-是怎么生效的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#arraymethods-是怎么生效的"}},[e._v("#")]),e._v(" arrayMethods 是怎么生效的？")]),e._v(" "),a("p",[e._v("现在我们有一个 "),a("code",[e._v("arrayMenthods")]),e._v(" 是被加工后的 "),a("code",[e._v("Array.prototype")]),e._v("，那么怎么让这个对象应用到"),a("code",[e._v("Array")]),e._v(" 上面呢？")]),e._v(" "),a("p",[e._v("思考一下，我们不能直接修改 "),a("code",[e._v("Array.prototype")]),e._v("因为这样会污染全局的Array，我们希望 "),a("code",[e._v("arrayMenthods")]),e._v(" 只对 "),a("code",[e._v("data")]),e._v("中的"),a("code",[e._v("Array")]),e._v(" 生效。")]),e._v(" "),a("p",[e._v("所以我们只需要把 "),a("code",[e._v("arrayMenthods")]),e._v(" 赋值给 "),a("code",[e._v("value")]),e._v(" 的 "),a("code",[e._v("__proto__")]),e._v(" 上就好了。")]),e._v(" "),a("p",[e._v("我们改造一下 "),a("code",[e._v("Observer")]),e._v("：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("export class Observer {\n  constructor (value: any) {\n    this.value = value\n    this.dep = new Dep()\n    this.vmCount = 0\n    def(value, '__ob__', this)\n\n    if (Array.isArray(value)) {\n      value.__proto__ = arrayMethods // 新增\n      this.observeArray(value)\n    } else {\n      this.walk(value)\n    }\n  }\n}\n")])])]),a("p",[e._v("如果不能使用 "),a("code",[e._v("__proto__")]),e._v("，就直接循环 "),a("code",[e._v("arrayMethods")]),e._v("把它身上的这些方法直接装到 "),a("code",[e._v("value")]),e._v(" 身上好了。")]),e._v(" "),a("p",[a("strong",[e._v("什么情况不能使用 "),a("code",[e._v("__proto__")]),e._v(" 我也不知道，各位大佬谁知道能否给我留个言？跪谢~")])]),e._v(" "),a("p",[e._v("所以我们的代码又要改造一下：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// can we use __proto__?\nconst hasProto = '__proto__' in {} // 新增\nexport class Observer {\n  constructor (value: any) {\n    this.value = value\n    this.dep = new Dep()\n    this.vmCount = 0\n    def(value, '__ob__', this)\n\n    if (Array.isArray(value)) {\n      // 修改\n      const augment = hasProto\n        ? protoAugment\n        : copyAugment\n      augment(value, arrayMethods, arrayKeys)\n      this.observeArray(value)\n    } else {\n      this.walk(value)\n    }\n  }\n}\n\nfunction protoAugment (target, src: Object, keys: any) {\n  target.__proto__ = src\n}\n\nfunction copyAugment (target: Object, src: Object, keys: Array<string>) {\n  for (let i = 0, l = keys.length; i < l; i++) {\n    const key = keys[i]\n    def(target, key, src[key])\n  }\n}\n")])])]),a("h2",{attrs:{id:"关于array的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关于array的问题"}},[e._v("#")]),e._v(" 关于Array的问题")]),e._v(" "),a("p",[e._v("关于vue对Array的拦截实现上面刚说完，正因为这种实现方式，其实有些数组操作vue是拦截不到的，例如：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("this.list[0] = 2\n")])])]),a("p",[e._v("修改数组第一个元素的值，无法侦测到数组的变化，所以并不会触发 "),a("code",[e._v("re-render")]),e._v(" 或 "),a("code",[e._v("watch")]),e._v(" 等。")]),e._v(" "),a("p",[e._v("在例如：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("this.list.length = 0\n")])])]),a("p",[e._v("清空数组操作，无法侦测到数组的变化，所以也不会触发 "),a("code",[e._v("re-render")]),e._v(" 或 "),a("code",[e._v("watch")]),e._v(" 等。")]),e._v(" "),a("p",[e._v("因为vue的实现方式就决定了无法对上面举得两个例子做拦截，也就没有办法做到响应，ES6是有能力做到的，在ES6之前是无法做到模拟数组的原生行为的，现在 ES6 的 Proxy 可以模拟数组的原生行为，也可以通过 ES6 的继承来继承数组原生行为，从而进行拦截。")]),e._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),a("p",[a("img",{attrs:{src:"defineReactive.assets/data.png",alt:"响应式结构图"}})]),e._v(" "),a("p",[e._v("最后掏出vue官网上的一张图，这张图其实非常清晰，就是一个变化侦测的原理图。")]),e._v(" "),a("p",[a("code",[e._v("getter")]),e._v(" 到 "),a("code",[e._v("watcher")]),e._v(" 有一条线，上面写着收集依赖，意思是说 "),a("code",[e._v("getter")]),e._v(" 里收集 "),a("code",[e._v("watcher")]),e._v("，也就是说当数据发生 "),a("code",[e._v("get")]),e._v(" 动作时开始收集 "),a("code",[e._v("watcher")]),e._v("。")]),e._v(" "),a("p",[a("code",[e._v("setter")]),e._v(" 到 "),a("code",[e._v("watcher")]),e._v(" 有一条线，写着 "),a("code",[e._v("Notify")]),e._v(" 意思是说在 "),a("code",[e._v("setter")]),e._v(" 中触发消息，也就是当数据发生 "),a("code",[e._v("set")]),e._v(" 动作时，通知 "),a("code",[e._v("watcher")]),e._v("。")]),e._v(" "),a("p",[a("code",[e._v("Watcher")]),e._v(" 到 ComponentRenderFunction 有一条线，写着 "),a("code",[e._v("Trigger re-render")]),e._v(" 意思很明显了。")])])}),[],!1,null,null,null);t.default=v.exports}}]);