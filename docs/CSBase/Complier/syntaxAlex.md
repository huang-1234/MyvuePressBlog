# 语法分析

## DFA自动机和NFA

## 求LL(1)分析表

#### 易错点及扩展：

1、求每个产生式的 SELECT 集

2、注意区分是对谁 FIRST 集 FOLLOW 集

3、开始符号的 FOLLOW 集包含 #

4、**各集合对对应的对象以及含义**

| 集        | 对象                       | 含义                                                         |
| --------- | -------------------------- | ------------------------------------------------------------ |
| FIRST 集  | 是对产生式右部             | 右部内部的所有终结符集，可能为 ε                             |
| FOLLOW 集 | 是对产生式左部（非终结符） | 非终结符后面紧跟的终结符，可能为 #，和该非终结符推导出的右部无关（因为LL(1)文法不包含递归，所以右部不会再有该非终结符，所以不能通过该右部判断该非终结符后跟集合） |
| SELECT 集 | 是对产生式                 | 需要考虑产生式右部的不同情况，进一步确定是根据 FIRST 集还是 FOLLOW 集 |

5、**SELECT 集的定义**
**注：** 注意区分 FIRST 集 FOLLOW 时是对 α 还是 A

> 给定文法 G，对于产生式 A→α，α ∈ V*，则可选集 SELECT(A→α) 有：
> （1）若 α ≠ ε，且 α ≠+> ε，则 SELECT(A→α) = FIRST(α)
> （2）若 α ≠ ε，但 α =+> ε，则 SELECT(A→α) = FIRST(α) ∪ FOLLOW(A)
> （3）若 α = ε，则 SELECT(A→α) = FOLLOW(A)

**描述：**

- 第 1 条是，当 α ≠ ε，且通过1次或多次推不出 ε，SELECT(A→α) = FIRST(α)

- 第 2 条是，当 α ≠ ε，但 α 经有限步可推出 ε，SELECT(A→α) = FIRST(α) ∪ FOLLOW(A)
  （注意是一个 α，一个 A）

- 第 3 条是，当 α = ε，SELECT 集就等于左部 A 的 FOLLOW 集

  解题时，先判断是否为 ε，是则用第（3）条，否则再判断能否通过1次或多次推出 ε，是则用第（2）条，否则用第（1）条

  求 FIRST，FOLLOW，SELECT 集详细例题可参考：
  [《编译原理》-用例题理解-自顶向下语法分析及 FIRST，FOLLOW，SELECT集，LL(1)文法](https://www.cnblogs.com/xpwi/p/10987443.html)

6、**LL(1) 分析表的结构**

分析表是一个二维数组 M[A，a]，其中 A 表示行，是非终结符，a 表式列是终结符或 #。

- M[A，a] 中若有产生式，表明 A 可用该产生式推导，以求与输入符号 a 匹配。
- M[A，a] 中若为空，表明 A 不可能推导出与 a 匹配的字符串

7、**LL(1) 分析表构造方法：**

- 若 a∈SELECT(A→α)，则把 A→α 加至 M[A, a] 中
- 把所有无定义的 M[A, a] 标上“出错标志”。为了使表简化，表中空白处为出错

#### 例题：

**已给文法：**

> **G[S]: S→aH
> H→aMd
> H→d
> M→Ab
> M→ε
> A→aM
> A→e**

（1）求 SELECT 集
（2）证明文法是 LL(1) 文法
（3）构造 LL(1) 分析表

**解析：**

**求 SELECT 集：**

| 产生式                                                       | FIRST 集 | FOLLOW 集          | SELECT 集                                                    |
| ------------------------------------------------------------ | -------- | ------------------ | ------------------------------------------------------------ |
| S→aH **分析：** 对该产生式，可知 FIRST(aH) = {a}；也可知应将 FOLLOW(S) = {#} 加到 FOLLOW(H) 中 | {a}      | FOLLOW(S) = {#}    | SELECT(S→aH) = FIRST(aH) = {a}                               |
| H→aMd **分析：** 对该产生式，可知 FIRST(aMd) = {a}；也可知应将 d 加到 FOLLOW(M) 中 | {a}      | FOLLOW(H) = {#}    | SELECT(H→aMd) = FIRST(aMd) = {a}                             |
| H→d **分析：** 对该产生式，可知 FIRST(d) = {d}               | {d}      |                    | SELECT(H→d) = FIRST(d) = {d}                                 |
| M→Ab **分析：** 对该产生式，可知 FIRST(Ab) = {a, e}；也可知应将 b 加到 FOLLOW(A) 中 | {a, e}   | FOLLOW(M) = {b, d} | SELECT(M→Ab) = FIRST(Ad) = {a, e}                            |
| M→ε                                                          | {ε}      |                    | SELECT(M→ε) = FOLLOW(M) ={d, b} **求法：** 由产生式 H→aMd，所以将 d 放入 FOLLOW(M)；由产生式 A→aM 所以把 FOLLOW(A) 加至 FOLLOW(M) 中。**同理** 求 FOLLOW(A)，由产生式 M→Ab，FOLLOW(A) = {b}。故 FOLLOW(M) = {d ,b} |
| A→aM **分析：** 对该产生式，可知 FIRST(aM) = {a}；也可知应将 FOLLOW(A) 加到 FOLLOW(M) 中 | {a}      | FOLLOW(A) = {b}    | SELECT(A→aM) = FIRST(aM) = {a}                               |
| A→e **分析：** 对该产生式，可知 FIRST(e) = {e}               | {e}      |                    | SELECT(A→e) = FIRST(e) = {e}                                 |

**证明文法是 LL(1) 文法（2 分）**

定理：同一非终结符的 SELECT 交集为空集，则该文法是 LL(1) 文法：

- SELECT(H→aMd) ∩ SELECT(H→d) = ∅
- SELECT(M→Ab) ∩ SELECT(M→ε) = ∅
- SELECT(A→aM) ∩ SELECT(A→e) = ∅

所以该文法是 LL(1) 文法

**构造 LL(1) 分析表（1 分）**

分析表是一个二维数组 M[A，a]，其中 A 表示行是非终结符，a 表式列是终结符或 #。根据 SELECT 集构造分析表：

|      | a     | b    | d    | e    |
| ---- | ----- | ---- | ---- | ---- |
| S    | S→aH  |      |      |      |
| H    | H→aMd |      | H→d  |      |
| M    | M→Ab  | M→ε  | M→ε  | M→Ab |
| A    | A→aM  |      |      | A→e  |



## 求 FIRSTVT 集和 LASTVT 集的步骤

算符优先关系表的构造中涉及到求 FIRSTVT 集和 LASTVT 集。

**表示及含义：**

| FIRSTVT(T)    | 非终结符T的最左终结符集合     |
| ------------- | ----------------------------- |
| **LASTVT(T)** | **非终结符T的最右终结符集合** |

**定义：**

![img](/images/CSBase/Complier/syntaxAlex.assets/FIRSTVTandLASTVT.png)

**定义解释：**

| FIRSTVT(T)    | 非终结符T经过1步或多步推导，得到的最左端终结符，以及左端第二个终结符的集合 |
| ------------- | ------------------------------------------------------------ |
| **LASTVT(T)** | **非终结符T经过1步或多步推导，得到的最右端终结符，以及倒数第二个终结符的集合** |

**求 FIRSTVT 集的步骤：**

（1）若有产生式 T→a 或者 T→Ra...，则 a ∈ FIRSTVT(T)

（2）若 a ∈ FIRSTVT(R)，且有产生式 T→R...，则 a ∈ FIRSTVT(T)

 就是说如果 a 是非终结符 R 的 FIRSTVT 集，且 T 可以推出以非终结 R 带头的右部，则 a 也是非终结符 T 的 FIRSTVT 集。

 **注：** 省略号 ... 可以为空，就是没有

**求 LASTVT 集的步骤：**

（1）若有产生式 T→...a 或者 T→...aR，则 a ∈ LASTVT(T)

（2）若 a ∈ LASTVT(R)，且有产生式 T→...R，则 a ∈ LASTVT(T)

**例题：**

> **已给文法：
> G[S]:
> S→a|b|(B)
> A→S, A|S
> B→A**

求所有非终结符的 FIRSTVT，LASTVT 集

##### 解析：

（1）只要是让求 FIRSTVT，LASTVT 集，则该文法就隐含条件为算符优先文法。

（2）算符优先文法的特点是：不会出现两个相邻的非终结符，即两个非终结符中间夹着一个终结符。如果第一个是终结符则第二个是非终结符。

**结果：**

|      | FIRSTVT 集       | LASTVT 集       |
| ---- | ---------------- | --------------- |
| S    | {a, b, ( }       | {a, b, ) }      |
| A    | {a, b, (, 逗号 } | {a, b, ), 逗号} |
| B    | {a, b, (, 逗号 } | {a, b, ), 逗号} |